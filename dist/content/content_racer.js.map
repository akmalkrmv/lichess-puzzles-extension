{
  "version": 3,
  "sources": ["../../src/models/race.model.ts", "../../src/content/content_racer.ts"],
  "sourcesContent": ["import {PuzzleId} from './common.js';\r\n\r\nexport type RaceId = string;\r\nexport type Puzzles = Pick<IRace, 'solved' | 'unsolved' | 'reviewed'>;\r\nexport type RaceStats = Pick<IRace, 'score' | 'rank' | 'totalPlayers'>;\r\n\r\nexport interface IRace {\r\n  raceId: RaceId;\r\n  timestamp: number;\r\n\r\n  // stats\r\n  score: number;\r\n  rank: number;\r\n  totalPlayers: number;\r\n\r\n  // puzzles\r\n  solved: PuzzleId[];\r\n  unsolved: PuzzleId[];\r\n  reviewed: PuzzleId[];\r\n}\r\n\r\nexport class Race implements IRace {\r\n  public timestamp: number = Date.now();\r\n\r\n  // stats\r\n  public score: number = 0;\r\n  public rank: number = 0;\r\n  public totalPlayers: number = 0;\r\n\r\n  // puzzles\r\n  public solved: PuzzleId[] = [];\r\n  public unsolved: PuzzleId[] = [];\r\n  public reviewed: PuzzleId[] = [];\r\n\r\n  constructor(public raceId: RaceId) {}\r\n\r\n  public setStats({score, rank, totalPlayers}: RaceStats): Race {\r\n    this.score = score || 0;\r\n    this.rank = rank || 0;\r\n    this.totalPlayers = totalPlayers || 0;\r\n    return this;\r\n  }\r\n  \r\n  public setPuzzles({solved, unsolved, reviewed}: Puzzles): Race {\r\n    this.solved = solved || [];\r\n    this.unsolved = unsolved || [];\r\n    this.reviewed = reviewed || [];\r\n    return this;\r\n  }\r\n}\r\n", "// Example href link of single race\r\n// https://lichess.org/racer/btUJ7\r\n\r\nimport {Race} from '../models';\r\nimport {MessageTypes} from '../messages';\r\n\r\n(function () {\r\n  const SELECTORS = {\r\n    history: '.puz-history',\r\n    score: '.puz-side__solved__text',\r\n    rank: '.race__post__rank',\r\n    solvedRounds: '.puz-history__round:has(good) a',\r\n    unsolvedRounds: '.puz-history__round:has(bad) a',\r\n  } as const;\r\n\r\n  const getText = (selector: string) => document.querySelector(selector)?.textContent || undefined;\r\n  const getLinks = (selector: string) => [...document.querySelectorAll(selector)].map((a: Element) => (a as HTMLAnchorElement).href);\r\n  const extractLastSegment = (href: string) => href.split('/').pop()!;\r\n\r\n  function collectPuzzles() {\r\n    const score: number = Number(getText(SELECTORS.score) ?? 0);\r\n    const rankString: string | undefined = getText(SELECTORS.score);\r\n\r\n    const solved: string[] = getLinks(SELECTORS.solvedRounds).map(extractLastSegment);\r\n    const unsolved: string[] = getLinks(SELECTORS.unsolvedRounds).map(extractLastSegment);\r\n    const reviewed: string[] = [];\r\n\r\n    // Extract rank and total players using the helper function\r\n    const {rank, totalPlayers} = extractRank(rankString);\r\n\r\n    // Ignore probable Idle\r\n    if (unsolved.length <= 1 && solved.length === 0) return;\r\n\r\n    // Extract puzzle ID (last path segment): e.g. https://lichess.org/racer/btUJ7\r\n    const raceId: string | undefined = extractLastSegment(location.pathname); // e.g. btUJ7\r\n    if (!raceId) return;\r\n\r\n    const newRace: Race = new Race(raceId);\r\n    newRace.setStats({score, rank, totalPlayers});\r\n    newRace.setPuzzles({solved, unsolved, reviewed});\r\n\r\n    chrome.runtime.sendMessage({\r\n      type: MessageTypes.puzzle_race_finished,\r\n      ...newRace,\r\n    });\r\n  }\r\n\r\n  // Function to extract rank and total players from the DOM\r\n  function extractRank(rankString: string | undefined): {rank: number; totalPlayers: number} {\r\n    let rank: number = 0;\r\n    let totalPlayers: number = 0;\r\n\r\n    if (rankString) {\r\n      const match = rankString.match(/Your rank:\\s*(\\d+)\\/(\\d+)/);\r\n      if (match) {\r\n        rank = Number(match[1]); // Rank number\r\n        totalPlayers = Number(match[2]); // Total players\r\n      }\r\n    }\r\n\r\n    return {rank, totalPlayers};\r\n  }\r\n\r\n  // The history list appears when race ends.\r\n  // Use MutationObserver so it works reliably.\r\n\r\n  const observer = new MutationObserver(() => {\r\n    const history: Element | null = document.querySelector(SELECTORS.history);\r\n    if (history) {\r\n      observer.disconnect();\r\n      collectPuzzles();\r\n    }\r\n  });\r\n\r\n  observer.observe(document.body, {childList: true, subtree: true});\r\n})();\r\n"],
  "mappings": ";;;AAqBO,MAAM,OAAN,MAA4B;AAAA,IAajC,YAAmB,QAAgB;AAAhB;AAZnB,WAAO,YAAoB,KAAK,IAAI;AAGpC;AAAA,WAAO,QAAgB;AACvB,WAAO,OAAe;AACtB,WAAO,eAAuB;AAG9B;AAAA,WAAO,SAAqB,CAAC;AAC7B,WAAO,WAAuB,CAAC;AAC/B,WAAO,WAAuB,CAAC;AAAA,IAEK;AAAA,IAE7B,SAAS,EAAC,OAAO,MAAM,aAAY,GAAoB;AAC5D,WAAK,QAAQ,SAAS;AACtB,WAAK,OAAO,QAAQ;AACpB,WAAK,eAAe,gBAAgB;AACpC,aAAO;AAAA,IACT;AAAA,IAEO,WAAW,EAAC,QAAQ,UAAU,SAAQ,GAAkB;AAC7D,WAAK,SAAS,UAAU,CAAC;AACzB,WAAK,WAAW,YAAY,CAAC;AAC7B,WAAK,WAAW,YAAY,CAAC;AAC7B,aAAO;AAAA,IACT;AAAA,EACF;;;AC3CA,GAAC,WAAY;AACX,UAAM,YAAY;AAAA,MAChB,SAAS;AAAA,MACT,OAAO;AAAA,MACP,MAAM;AAAA,MACN,cAAc;AAAA,MACd,gBAAgB;AAAA,IAClB;AAEA,UAAM,UAAU,CAAC,aAAqB,SAAS,cAAc,QAAQ,GAAG,eAAe;AACvF,UAAM,WAAW,CAAC,aAAqB,CAAC,GAAG,SAAS,iBAAiB,QAAQ,CAAC,EAAE,IAAI,CAAC,MAAgB,EAAwB,IAAI;AACjI,UAAM,qBAAqB,CAAC,SAAiB,KAAK,MAAM,GAAG,EAAE,IAAI;AAEjE,aAAS,iBAAiB;AACxB,YAAM,QAAgB,OAAO,QAAQ,UAAU,KAAK,KAAK,CAAC;AAC1D,YAAM,aAAiC,QAAQ,UAAU,KAAK;AAE9D,YAAM,SAAmB,SAAS,UAAU,YAAY,EAAE,IAAI,kBAAkB;AAChF,YAAM,WAAqB,SAAS,UAAU,cAAc,EAAE,IAAI,kBAAkB;AACpF,YAAM,WAAqB,CAAC;AAG5B,YAAM,EAAC,MAAM,aAAY,IAAI,YAAY,UAAU;AAGnD,UAAI,SAAS,UAAU,KAAK,OAAO,WAAW,EAAG;AAGjD,YAAM,SAA6B,mBAAmB,SAAS,QAAQ;AACvE,UAAI,CAAC,OAAQ;AAEb,YAAM,UAAgB,IAAI,KAAK,MAAM;AACrC,cAAQ,SAAS,EAAC,OAAO,MAAM,aAAY,CAAC;AAC5C,cAAQ,WAAW,EAAC,QAAQ,UAAU,SAAQ,CAAC;AAE/C,aAAO,QAAQ,YAAY;AAAA,QACzB;AAAA,QACA,GAAG;AAAA,MACL,CAAC;AAAA,IACH;AAGA,aAAS,YAAY,YAAsE;AACzF,UAAI,OAAe;AACnB,UAAI,eAAuB;AAE3B,UAAI,YAAY;AACd,cAAM,QAAQ,WAAW,MAAM,2BAA2B;AAC1D,YAAI,OAAO;AACT,iBAAO,OAAO,MAAM,CAAC,CAAC;AACtB,yBAAe,OAAO,MAAM,CAAC,CAAC;AAAA,QAChC;AAAA,MACF;AAEA,aAAO,EAAC,MAAM,aAAY;AAAA,IAC5B;AAKA,UAAM,WAAW,IAAI,iBAAiB,MAAM;AAC1C,YAAM,UAA0B,SAAS,cAAc,UAAU,OAAO;AACxE,UAAI,SAAS;AACX,iBAAS,WAAW;AACpB,uBAAe;AAAA,MACjB;AAAA,IACF,CAAC;AAED,aAAS,QAAQ,SAAS,MAAM,EAAC,WAAW,MAAM,SAAS,KAAI,CAAC;AAAA,EAClE,GAAG;",
  "names": []
}
